# Clonal Evolution analysis using ClonEvol

The following uses outputs from PyClone-VI to build a phylogenetic tree of the evolutionary pattern of clonal populaitons
in the chroangioma from the PVP project. This follows the instructions set forth by the ClonEvol authors in their
setup and use guide.

### Load in libraries
```{r message=FALSE, warning=FALSE}
install.packages("devtools", repos = "https://mirror.las.iastate.edu/CRAN/")
library(devtools)
install_github("hdng/clonevol")
install_github("hdng/trees")
install.packages("gridBase")
install.packages("gridExtra")
install.packages("ggplot2")
install.packages("igraph", type = "binary")
install.packages("packcircles")
```

## Workflow

From the authors docs the workflow of mapping the clonal evolution are:

  1. Preparing a comprehensive and reliable set of somatic mutations
  2. Clustering the mutations based on cellular prevalence
  3. Evaluating the clustering results
  4. Inferring clonal evolution trees (ie. clonal ordering)
  5. Visualizing data and clonal evolution trees
  6. Interpreting the results

Steps 1 and 2 are already already completed using Mutect2, CNVkit, and PyClone-VI. ClonEvol will be helping with
steps 3 thorugh 6.

## Analysis

### Data Prep

After reviewing the parameters for PyClone-VI and the outputs we'll be analyzing the clusters produced from the binomial
distribution. The authors of ClonEvol note: ClonEvol requires an input data frame consisting of at least a cluster
column and one or more variant cellular prevalence columns, each corresponds to a sample.
The cluster should be named by contiguous integer numbers, starting from 1. For better
visualization, the names of the cellular prevalence columns should be short.

Note from PyClone-VI authors: the column labeled "cellular_prevalence" = Proportion of malignant cells with the 
mutation in the sample. This is also called cancer cell fraction (CCF) in the literature. For this analysis I'll use
the betabinomial probability density used to model the read count data by PyClone-VI since the authors note that
> beta-binomial is useful when the data is over-dispersed which has been observed frequently in sequencing data.

```{r}
library(clonevol)
df <- read.table(file = "data/40depth-20vaf-clonevol-input/pvp-beta_binomial_clonal-clonevol.tsv", header = TRUE, sep = "\t")
```


ClonEvol expects cluster IDs to be integer values starting at 1, however PyClone-VI starts cluster IDs at zero so we
need to increase each cluster ID by 1 before we can generate inference. Guessing from the ClonEvol demo data we also
need to convert the CCF info from a decimal fraction to a percent, and possibly include depth information :shrug:

```{r}
nonint_cols <- c("mutation_id", "cluster", "is_interesting", "gene")
df[, !colnames(df) %in% nonint_cols] <- df[, !colnames(df) %in% nonint_cols] * 100

# setup the order of clusters to display in various plots (later)
df <- df[order(df$cluster), ]
```

For formatting the dataframe ClonEvol only uses the cluster IDs (contiguous integer starting from 1) and CCF
for phylogenetic structure determination. Other information can be contained within the dataframe for
other QC and computations done.

## Visualizing Clusters

One of the noted things to do is to manually review the clustering. This visual check aids in determining if accurate
clusters were determined by PyClone-VI and if any clusters should be excluded for particular samples. According to
the ClonEvol docs

```text
When evaluating the clusters, look for potential outlier clusters (eg. ones with small number of variants),
potential merged clusters (eg. ones that have variants with VAF stretching from zero to non-zero values in multiple
samples, that can be further splitted in to multiple clusters), noise clusters (eg. ones that show very similar and low
VAF across samples, indicating false variant calls). These conditions could be more relaxed with deeper sequencing as
clustering can be more accurate.
```

```{r}
pvaf <- plot.variant.clusters(df,
  cluster.col.name = "cluster",
  show.cluster.size = FALSE,
  cluster.size.text.color = "blue",
  vaf.col.names = grep("_vaf", colnames(df), value = TRUE),
  sample.title.size = 20,
  violin = FALSE,
  box = FALSE,
  jitter = TRUE,
  jitter.color = NULL,
  display.plot = FALSE,
  order.by.total.vaf = FALSE
)
plot(pvaf[[1]])
plot(pvaf[[2]])
```


## Ordering and Tree building

Since we used PyClone-VI to estimate copy number corrected CCF values we can provide the corrected CCF to ClonEvol via 
`ccf.col.names` parameter in `infer.clonal.models` function:

```{r}
# rename VAF columns for better sample labeling in output diagrams
vaf_col_names <- grep("_vaf", colnames(df), value = TRUE)
sample_names <- gsub("_vaf", "", vaf_col_names)
sample_names <- gsub("NORM_VILLI", "Normal_Villi", sample_names)
sample_names <- gsub("CHORANGIOMA", "Chorangioma", sample_names)
df[, sample_names] <- df[, vaf_col_names]
vaf_col_names <- sample_names

# define clone colors
clone_colors <- c("#648FFF", "#009E73", "#CC79A7")

# compute clonal models
y <- infer.clonal.models(
  variants = df,
  cluster.col.name = "cluster",
  vaf.col.names = vaf_col_names,
  clone.colors = clone_colors,
  cancer.initiation.model = "monoclonal",
  subclonal.test = "bootstrap",
  subclonal.test.model = "non-parametric",
  num.boots = 1000,
  founding.cluster = 1,
  cluster.center = "mean",
  ignore.clusters = NULL,
  min.cluster.vaf = 0.01,
  # min probability that CCF(clone) is non-negative
  sum.p = 0.05,
  # alpha level in confidence interval estimate for CCF(clone)
  alpha = 0.05
)

# map interesting variants/genes onto the tree if present
if (dim(df[df$is_interesting, ])[1] > 0) {
  y <- transfer.events.to.consensus.trees(
    y,
    df[df$is_interesting, ],
    cluster.col.name = "cluster",
    event.col.name = "gene"
  )
}

# scale size of # of variants in cluster by square root transform
y <- convert.consensus.tree.clone.to.branch(y, branch.scale = "sqrt")
```

Plot the evolution dynamics in a PDF

```{r}
plot.clonal.models(
  y,
  disable.sample.label = TRUE,
  # box plot parameters
  box.plot = TRUE,
  fancy.boxplot = TRUE,
  fancy.variant.boxplot.jitter.alpha = 1,
  fancy.variant.boxplot.jitter.center.color = "grey50",
  fancy.variant.boxplot.base_size = 12,
  fancy.variant.boxplot.plot.margin = 1,
  fancy.variant.boxplot.vaf.suffix = " Cellular Fraction",
  # bell plot parameters
  clone.shape = "bell",
  bell.event = TRUE,
  bell.event.label.color = "blue",
  bell.event.label.angle = 60,
  clone.time.step.scale = 1.25,
  bell.curve.step = 1,
  # node-based consensus tree parameters
  merged.tree.plot = FALSE,
  tree.node.label.split.character = NULL,
  tree.node.shape = "circle",
  tree.node.size = 30,
  tree.node.text.size = 0.5,
  merged.tree.node.size.scale = 1.25,
  merged.tree.node.text.size.scale = 1.5,
  merged.tree.cell.frac.ci = FALSE,
  # branch-based consensus tree parameters
  merged.tree.clone.as.branch = TRUE,
  mtcab.event.sep.char = ",",
  mtcab.branch.text.size = 1,
  mtcab.branch.width = 0.25,
  mtcab.node.size = 6,
  mtcab.node.label.size = 2,
  mtcab.node.text.size = 1,
  # cellular population parameters
  cell.plot = TRUE,
  num.cells = 200,
  cell.border.size = 0.25,
  cell.border.color = "black",
  clone.grouping = "horizontal",
  # meta-parameters
  scale.monoclonal.cell.frac = TRUE,
  show.score = FALSE,
  cell.frac.ci = TRUE,
  disable.cell.frac = FALSE,
  # output figure parameters
  out.dir = "data/40depth-20vaf-clonevol-output",
  out.format = "pdf",
  overwrite.output = TRUE,
  width = 16,
  height = 10,
  # vector of width scales for each panel from left to right
  panel.widths = c(3, 5, 4, 4)
)

print("Done")
```